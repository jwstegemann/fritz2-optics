package io.fritz2.optics


import com.squareup.kotlinpoet.*
import de.jensklingenberg.mpapt.common.guessingSourceSetFolder
import de.jensklingenberg.mpapt.model.AbstractProcessor
import de.jensklingenberg.mpapt.model.Element
import de.jensklingenberg.mpapt.model.RoundEnvironment
import de.jensklingenberg.mpapt.utils.KotlinPlatformValues
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.name.FqNameUnsafe
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import java.io.File
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe

data class LensSpecs(val property: PropertySpec, val extension: FunSpec)

class LensesProcessor() : AbstractProcessor() {
    val optics = Lenses::class.java.name
    val annotatedClasses = mutableListOf<ClassDescriptor>()

    override fun process(roundEnvironment: RoundEnvironment) {

        roundEnvironment.getElementsAnnotatedWith(optics).forEach { element ->
            when (element) {
                is Element.ClassElement -> {
                    if (element.classDescriptor.isData) annotatedClasses.add(element.classDescriptor)
                }
            }
        }


    }

    override fun isTargetPlatformSupported(platform: TargetPlatform): Boolean {
        val targetName = platform.first().platformName

        return when (targetName) {
            KotlinPlatformValues.JS -> true
            KotlinPlatformValues.JVM -> false
            else -> {
                log(targetName)
                false
            }
        }

    }

    override fun getSupportedAnnotationTypes(): Set<String> = setOf(optics)

    override fun processingOver() {
        for (pkg in annotatedClasses.groupBy { it.containingDeclaration.fqNameSafe.asString() }) {
            buildFile(pkg)
        }
    }

    private fun buildFile(entry: Map.Entry<String, List<ClassDescriptor>>) {
        val packageName = entry.key

        val fileSpecBuilder = FileSpec.builder(packageName, "GeneratedOptics")
            .addComment("GENERATED by io.fritz2.optics")
            .addComment(" - NEVER CHANGE CONTENT MANUALLY!")
            .addImport("io.fritz2.optics", "buildLens")

        annotatedClasses.flatMap { buildFunctionsForClass(it) }.forEach {
            fileSpecBuilder.addProperty(it.property)
            //fileSpecBuilder.addFunction(it.extension)
        }

        //FIXME: better way to determine source path
        val filepath = annotatedClasses.first().guessingSourceSetFolder().substringBefore(packageName.replace('.','/'))
        fileSpecBuilder.build().writeTo(File(filepath))
    }


    private fun buildFunctionsForClass(classDescriptor: ClassDescriptor): List<LensSpecs> =
        classDescriptor.constructors.first().valueParameters.map {
            buildExtensionFunction(classDescriptor, it)
        }

    private fun stringToClassName(name: String): TypeName {
        val hasParam = name.contains('<')
        val typeString = if (hasParam) name.substringBefore('<') else name

        val typeList = typeString.split(".")
        val classString = typeList.last()
        val packageString = typeList.dropLast(1).joinToString(".")
        val className = ClassName(packageString, classString)

        return if (hasParam) {
            //FIXME: handle more type parameters and nested ones
            val parameterString = name.substringAfter('<').substringBefore('>')
            className.plusParameter(stringToClassName(parameterString))
        } else {
            className
        }
    }


    private fun buildExtensionFunction(classDescriptor: ClassDescriptor, parameterDescriptor: ValueParameterDescriptor): LensSpecs {

        val outerTypeName = stringToClassName(classDescriptor.defaultType.getJetTypeFqName(false))
        val innerTypeName = stringToClassName(parameterDescriptor.type.getJetTypeFqName(true))

        val attributeName = parameterDescriptor.name.toString()

        val lensTypeName = ClassName("io.fritz2.optics","Lens")
            .plusParameter(outerTypeName)
            .plusParameter(innerTypeName)

        //TODO: TypeParameters, Typed data classes?
        val outerNamePart = classDescriptor.fqNameUnsafe.shortName()

//        val outerNamePart = outerTypeName.toString()
//            .replace('.','_')
//            .replace('<','-')
//            .replace('>','-')

        //val propertyName = ("Lens_${outerNamePart}_$attributeName").take(255)
        val propertyName = ("${outerNamePart}${attributeName.capitalize()}Lens").take(255)

        val property = PropertySpec.builder(propertyName, lensTypeName)
            .initializer("buildLens({ it.$attributeName },{ p, v -> p.copy($attributeName = v)})")
            .build()

        val extension = FunSpec.builder("${attributeName}Lens")
            .addModifiers(KModifier.INLINE)
            .receiver(outerTypeName)
            .addStatement("return $propertyName")
            .build()

        return LensSpecs(property, extension)
    }

}
