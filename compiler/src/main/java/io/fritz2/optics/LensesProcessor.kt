package io.fritz2.optics


import com.squareup.kotlinpoet.*
import de.jensklingenberg.mpapt.common.guessingSourceSetFolder
import de.jensklingenberg.mpapt.model.AbstractProcessor
import de.jensklingenberg.mpapt.model.Element
import de.jensklingenberg.mpapt.model.RoundEnvironment
import de.jensklingenberg.mpapt.utils.KotlinPlatformValues
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import java.io.File
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameUnsafe

data class LensSpecs(val property: PropertySpec, val extension: FunSpec)

class LensesProcessor() : AbstractProcessor() {
    val optics = Lenses::class.java.name
    val annotatedClasses = mutableListOf<ClassDescriptor>()

    override fun process(roundEnvironment: RoundEnvironment) {

        roundEnvironment.getElementsAnnotatedWith(optics).forEach { element ->
            when (element) {
                is Element.ClassElement -> {
                    if (element.classDescriptor.isData) annotatedClasses.add(element.classDescriptor)
                }
            }
        }


    }

    override fun isTargetPlatformSupported(platform: TargetPlatform): Boolean {
        val targetName = platform.first().platformName

        return when (targetName) {
            KotlinPlatformValues.JS -> true
            KotlinPlatformValues.JVM -> false
            else -> {
                log(targetName)
                false
            }
        }

    }

    override fun getSupportedAnnotationTypes(): Set<String> = setOf(optics)

    override fun processingOver() {
        for (pkg in annotatedClasses.groupBy { it.containingDeclaration.fqNameSafe.asString() }) {
            buildFile(pkg)
        }
    }

    private fun buildFile(entry: Map.Entry<String, List<ClassDescriptor>>) {
        val packageName = entry.key

        val fileSpecBuilder = FileSpec.builder(packageName, "GeneratedOptics")
            .addComment("GENERATED by io.fritz2.optics")
            .addComment(" - NEVER CHANGE CONTENT MANUALLY!")
            .addImport("io.fritz2.optics", "buildLens")

        val lensesObject = TypeSpec.objectBuilder("Lenses")
        annotatedClasses.forEach {
            lensesObject.addType(buildClassObject(it))
        }

        fileSpecBuilder.addType(lensesObject.build())

        //FIXME: better way to determine source path
        val filepath = annotatedClasses.first().guessingSourceSetFolder().substringBefore(packageName.replace('.','/'))
        fileSpecBuilder.build().writeTo(File(filepath))
    }


    private fun buildClassObject(classDescriptor: ClassDescriptor): TypeSpec {
        val classObject = TypeSpec.objectBuilder(classDescriptor.fqNameUnsafe.shortName().toString())
        classDescriptor.constructors.first().valueParameters.forEach {
            classObject.addProperty(buildProperty(classDescriptor, it))
        }
        return classObject.build()
    }

    private fun stringToClassName(name: String): TypeName {
        val hasParam = name.contains('<')
        val typeString = if (hasParam) name.substringBefore('<') else name

        val typeList = typeString.split(".")
        val classString = typeList.last()
        val packageString = typeList.dropLast(1).joinToString(".")
        val className = ClassName(packageString, classString)

        return if (hasParam) {
            //FIXME: handle more type parameters and nested ones
            val parameterString = name.substringAfter('<').substringBefore('>')
            className.plusParameter(stringToClassName(parameterString))
        } else {
            className
        }
    }


    private fun buildProperty(classDescriptor: ClassDescriptor, parameterDescriptor: ValueParameterDescriptor): PropertySpec {

        val outerTypeName = stringToClassName(classDescriptor.defaultType.getJetTypeFqName(false))
        val innerTypeName = stringToClassName(parameterDescriptor.type.getJetTypeFqName(true))

        val attributeName = parameterDescriptor.name.toString()

        val lensTypeName = ClassName("io.fritz2.optics","Lens")
            .plusParameter(outerTypeName)
            .plusParameter(innerTypeName)

        return PropertySpec.builder(attributeName, lensTypeName)
            .initializer("buildLens({ it.$attributeName },{ p, v -> p.copy($attributeName = v)})")
            .build()
    }

}
