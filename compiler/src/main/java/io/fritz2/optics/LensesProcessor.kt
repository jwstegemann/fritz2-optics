package io.fritz2.optics


import com.squareup.kotlinpoet.*
import de.jensklingenberg.mpapt.common.guessingSourceSetFolder
import de.jensklingenberg.mpapt.model.AbstractProcessor
import de.jensklingenberg.mpapt.model.Element
import de.jensklingenberg.mpapt.model.RoundEnvironment
import de.jensklingenberg.mpapt.utils.KotlinPlatformValues
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.name.FqNameUnsafe
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import java.io.File
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter


class LensesProcessor() : AbstractProcessor() {
    val optics = Lenses::class.java.name
    val annotatedClasses = mutableListOf<ClassDescriptor>()

    override fun process(roundEnvironment: RoundEnvironment) {

        roundEnvironment.getElementsAnnotatedWith(optics).forEach { element ->
            when (element) {
                is Element.ClassElement -> {
                    if (element.classDescriptor.isData) annotatedClasses.add(element.classDescriptor)
                }
            }
        }


    }

    override fun isTargetPlatformSupported(platform: TargetPlatform): Boolean {
        val targetName = platform.first().platformName

        return when (targetName) {
            KotlinPlatformValues.JS -> true
            KotlinPlatformValues.JVM -> false
            else -> {
                log(targetName)
                false
            }
        }

    }

    override fun getSupportedAnnotationTypes(): Set<String> = setOf(optics)

    override fun processingOver() {
        val packageName = annotatedClasses.first().containingDeclaration.fqNameSafe.asString()

        val fileSpecBuilder = FileSpec.builder(packageName, "Optics")
            .addComment("GENERATED by io.fritz2.optics")
            .addComment("NEVER CHANGE CONTENT MANUALLY!")
            .addImport("io.fritz2.optics", "buildLens")
            .addImport("kotlin.reflect","KProperty1")

        annotatedClasses.flatMap { buildFunctionsForClass(it) }.forEach {
            fileSpecBuilder.addFunction(it)
        }

        //FIXME: better way to determine source path
        val filepath = annotatedClasses.first().guessingSourceSetFolder().substringBefore(packageName.replace('.','/'))
        fileSpecBuilder.build().writeTo(File(filepath))

    }

    //operator fun KProperty1<Outer, Inner>.not(): Lens<Outer, Inner> = buildLens(this) { p, v -> p.copy(inner = v)}

    private fun buildFunctionsForClass(classDescriptor: ClassDescriptor): List<FunSpec> =
        classDescriptor.constructors.first().valueParameters.map {
            buildExtensionFunction(classDescriptor, it)
        }


    fun createClassName(fq: FqNameUnsafe): ClassName {
        val shortName = fq.shortNameOrSpecial().toString()
        val pack = fq.asString().substringBefore(shortName).trim('.')
        return ClassName(pack,shortName)
    }

    private fun stringToClassName(name: String): TypeName {
        val hasParam = name.contains('<')
        val typeString = if (hasParam) name.substringBefore('<') else name

        val typeList = typeString.split(".")
        val classString = typeList.last()
        val packageString = typeList.dropLast(1).joinToString(".")
        val className = ClassName(packageString, classString)

        return if (hasParam) {
            //FIXME: handle more type parameters and nested ones
            val parameterString = name.substringAfter('<').substringBefore('>')
            className.plusParameter(stringToClassName(parameterString))
        } else {
            className
        }
    }

    private fun buildExtensionFunction(classDescriptor: ClassDescriptor, parameterDescriptor: ValueParameterDescriptor): FunSpec {

        val outerTypeName = stringToClassName(classDescriptor.defaultType.getJetTypeFqName(false))
        val innerTypeName = stringToClassName(parameterDescriptor.type.getJetTypeFqName(true))

        val attributeName = parameterDescriptor.name

        val receiverType = ClassName("kotlin.reflect","KProperty1")
            .plusParameter(outerTypeName)
            .plusParameter(innerTypeName)

        return FunSpec.builder("not")
            .addModifiers(KModifier.OPERATOR)
            .receiver(receiverType)
            .addStatement("return buildLens(this) {p,v -> p.copy($attributeName = v)}")
            .build()
    }

}
